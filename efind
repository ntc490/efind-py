#!/usr/bin/python
import re
import sets
import os
import sys
from docopt import docopt
"""
Enhanced Find Utility
Copyright (C) 2018 Nathan Crapo

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>

Contact me at:
nathan underscore crapo at yahoo mail
"""


class FileExtensionFilter:
    def __init__(self, extensions=None, name='', alt_names=[]):
        """
        Create a new object to filter files based on their extension name.  Object must have
        a name.  Can be crated with a list of extensions.  Extensions can be added later.
        """
        self.name = name
        self.alt_names = alt_names
        self.regex = None
        self.extensions = sets.Set()
        if extensions is not None:
            self.add_extensions(extensions)
        else:
            self.clear()

    def add_extensions(self, extensions):
        """
        Add an array of extensions or a string with extensions
        separated by whitespace to the filter.  Leave 'dot' out of
        expressions.
        """
        if isinstance(extensions, str):
            extensions = extensions.split()

        # remove preceding dots from extension name
        clean_extension_list = [re.sub(r'^\.*', '', e) for e in extensions]
        self.extensions.update(clean_extension_list)
        self._compile_extension_regex()

    def clear(self):
        """
        Clear the list of extensions so the filter is empty and allows
        all files.
        """
        self.extensions = sets.Set()
        self._compile_allow_all_regex()

    def is_name_match(self, name):
        """
        Check arg against filter names
        """
        if name == self.name or name in self.alt_names:
            return True
        return False

    def is_file_match(self, filename):
        """
        Determine if a filename has one of the desired extensions.
        """
        return self.regex.search(filename)

    def __repr__(self):
        description =  "%s" % (" ".join(self.extensions))
        return description

    def __str__(self):
        description =  "%s: %s" % (self.name, ", ".join(self.extensions))
        return description

    def _compile_extension_regex(self):
        # Compiling the expression should make it quicker
        expressions = ["\\.%s$" % e for e in self.extensions]
        expression = '(' + '|'.join(expressions) + ')'
        self.regex = re.compile(expression)

    def _compile_allow_all_regex(self):
        self.regex = re.compile(r'.*')


"""
Common groups of extensions for users to leverage
"""
FILE_TYPES = [
    FileExtensionFilter(extensions="""
    ai bmp dds drw dxf eps gif icn ico icon
    indd j2c j2k jfi jfif jif jiff jng jp2
    jpc jpe jpeg jpf jpg jpx jtf mng pct pdn
    png psd psp svg tga tif tiff xbm
    """, name='pics', alt_names=['pictures',]),
    FileExtensionFilter("""
    asx b4s m3u m3u8 pls wax
    wmx wpl xspf
    """, name='playlist'),
    FileExtensionFilter("""
    7z arc arj bzip2 cab chm cpio gz gzip iso
    lzh msi rar rpm sea sit sitx tar wim z zip
    """, name='archive'),
    FileExtensionFilter("""
    aac ac3 aif aiff ape atrac au dss dts dvf
    flac gsm iff m4a m4p mid midi mka mp1 mp2
    mp3 mpa msv ogg oma omg ra ram vox wav wma
    """, name='audio'),
    FileExtensionFilter("""
    abw doc docx dot mdb mde odb odc odf odg
    odi odm odp ods odt pdf pot ppt pptx ps
    qxd qxp rtf xls xlsx xlt
    """, name='documents'),
    FileExtensionFilter("""
    bat com exe
    """, name='executable'),
    FileExtensionFilter("""
    adb ada ads asm bas bb bmx c cbl cc cgi
    cls cob cpp cs csproj cxx d dpr e efs
    egt el f f77 f90 for frm frx ftn ged gm6
    gmd gmk gmi h hpp hs hxx inc java js
    jsp l lisp m m4 mi n p pas php php3
    php4 php5 phps phtml piv pl pm pp prg
    py rc rc2 resx s sce sci scm skb skc
    skd skf skg ski skk skm sko skp skq sks
    skt skz sin spin stk vap vb vbg vbp
    vbproj vbs vcproj vdproj vip y
    """, name='programming'),
    FileExtensionFilter("""
    a o
    """, name='object'),
    FileExtensionFilter("""
    cpp cxx h hpp
    """, name='c++'),
    FileExtensionFilter("""
    c h
    """, name='C'),
    FileExtensionFilter("""
    3gp asf avi divx dv flv m1v m2ts m2v m4v
    mkv mov mp4 mpe mpeg mpg mts ogm qt rm
    ts vob wmv
    """, name='video'),
    FileExtensionFilter("""
    asp chm css dhtml htm html jhtml js jsp
    jspx mht mhtml php php3 php4 php5 phtml
    rhtml rjs sht shtm shtml xht xhtml
    """, name='web'),
    FileExtensionFilter("""
    log txt
    """, name='text'),
]


class PathSpec:
    """
    Path Specifications apply to a _single_ directory.  The 'include'
    or 'exclude' files and/or sub-directories.
    """
    def __init__(self, directory):
        self.recurse = True
        self.file_inclusions = sets.Set()
        self.file_exclusions = sets.Set()
        self.dir_inclusions = sets.Set()
        self.dir_exclusions = sets.Set()
        self.directory = directory

    def include(self, path):
        """
        Inlude a directory or file.  Path must not be more than a
        single level deep.  The object's directory defines the
        location.
        """
        full_path = os.path.join(self.directory, path)
        if os.path.isdir(full_path):
            self._include_dir(path)
        else:
            self._include_file(path)

    def exclude(self, path):
        """
        Exclude a directory or file.  Path must not be more than a
        single level deep.  The object's directory defines the
        location.
        """
        full_path = os.path.join(self.directory, path)
        if os.path.isdir(full_path):
            self._exclude_dir(path)
        else:
            self._exclude_file(path)

    def _include_dir(self, path):
        self.dir_inclusions.update([path])

    def _include_file(self, path):
        self.file_inclusions.update([path])

    def _exclude_dir(self, path):
        self.dir_exclusions.update([path])

    def _exclude_file(self, path):
        self.file_exclusions.update([path])


class Repo:
    def __init__(self):
        self.repo_dir = ''

    def auto_locate(self, path=None):
        """
        Walk up from start_dir to end_dir and look for repo.  Usually a dir
        named .efind
        """
        efind_repo = '.efind'
        search_dir = path or '.'
        home_dir = os.getenv('HOME') or os.path.sep
        while os.path.abspath(search_dir) != home_dir:
            if efind_repo in os.listdir(search_dir):
                self.repo_dir = os.path.abspath(os.path.join(search_dir, efind_repo))
                return self.repo_dir
            search_dir = os.path.join(search_dir, os.path.pardir)
        return None

    def get_root(self, absolute_path=False):
        """
        Get root of the search
        """
        root = os.path.join(self.repo_dir, os.path.pardir)
        relpath = os.path.relpath(root, os.getcwd())
        if absolute_path:
            return os.path.abspath(relpath)
        else:
            return relpath

    def get_config_filename(self, name=None):
        if name is None:
            name = 'default'
        return os.path.join(self.get_repo_dir(), name)

    def get_repo_dir(self):
        """Get repo directory - including .efind portion"""
        return self.repo_dir

    def config(self, name, path='.'):
        """
        Select config named 'name' in repo - OR create a new config in
        repo if one doesn't exist with that name already.
        """
        pass


class Finder:
    """
    This class is used to find files and directories.  It filters
    output based on PathSpec objects and a single global file
    extension filter.  Use text commands to configure the Finder
    object and then call the find method.
    """
    def __init__(self, root):
        """
        The root path must be known at object creation time so the
        PathSpec objects can be properly created when the config()
        method is called.
        """
        self.root = root
        self.path_specs = []
        self.file_type = None

    def config(self, command):
        """

        Pass a command or sequence of commands delimited by semicolons
        to this function to create PathSpecs and set the global
        filter.  Use of the 'at' keyword can be used to set the path
        where the PathSpec takes effect.  Use the 'include' and
        'exclude' command to include or exclude directories and files.
        If you 'include' a file or directory, any unspecified files
        will be ignored.  If you 'exclude' a file or directory, all
        files or directories except those specified will be included.
        Multiple single level paths may be included or excluded with
        one command.  Use spaces to separate entries.

        A few examples are shown below:

        at . include drivers include documentation
        include drivers include
        at src/common exclude i2c-base.c
        type pictures
        type programming;at src include foo bar
        """
        command_words = command.split()
        command_word_offset = 0
        if len(command_words) < 2:
            sys.stderr.write("command too short: %s\n" % command)
            return -1
        directory = ""
        if command_words[0] == 'at':
            directory = command_words[1]
            command_word_offset = 2
            # Command must be longer when the 'at' keyword is used
            if len(command_words) < 4:
                sys.stderr.write("command too short: %s\n" % command)
                return -1
        # PathSpec objects must include the root they reference
        directory = os.path.join(self.root, directory)
        directory = os.path.normpath(directory)
        if command_words[command_word_offset] == 'include':
            self._include(directory, command_words[command_word_offset + 1:])
        elif command_words[command_word_offset] == 'exclude':
            self._exclude(directory, command_words[command_word_offset + 1:])
        elif command_words[command_word_offset] == 'type':
            self.set_file_type(command_words[command_word_offset + 1])
        else:
            sys.stderr.write("invalid command: %s\n" % command)

    def find(self, subtree=None):
        """
        Start locating files or directories using the PathSpec and
        file type filter and print results to stdout.  Passing a subtree
        only prints that portion of the results.
        """
        path_specs = self.path_specs[:]
        for root, directories, files in os.walk(self.root, topdown=True):
            if subtree and not self._in_subtree(subtree, os.path.abspath(root)):
                continue
            path_spec_name = os.path.normpath(root)
            path_spec = self._get_path_spec(path_specs, path_spec_name)
            if path_spec:
                self._filter_dirs(path_spec, directories)
                self._filter_files(path_spec, files)
            self._print_files(root, files)

    def set_file_type(self, file_type):
        """
        Narrow results based on file extensions
        """
        for ftype in FILE_TYPES:
            if ftype.is_name_match(file_type):
                self.file_type = ftype
        if self.file_type is None:
            raise ValueError('Invalid file type: %s' % file_type)

    def _include(self, path, sub_paths):
        spec = self._get_path_spec(self.path_specs, path)
        if not spec:
            spec = PathSpec(path)
            self.path_specs.append(spec)
        for sub_path in sub_paths:
            if os.path.dirname(sub_path):
                # If the addition includes multiple directories, call self
                # recursively at each level
                implicit_dir = sub_path.split(os.sep)[0]
                complex_path = os.path.join(*sub_path.split(os.sep)[1:])
                new_path = os.path.join(path, implicit_dir)
                current_new_dir = implicit_dir.split(os.sep)[0]
                spec.include(current_new_dir)
                self._include(new_path, [complex_path])
            else:
                spec.include(sub_path)

    def _exclude(self, path, sub_paths):
        spec = self._get_path_spec(self.path_specs, path)
        if not spec:
            spec = PathSpec(path)
            self.path_specs.append(spec)
        for sub_path in sub_paths:
            if os.path.dirname(sub_path):
                sys.stderr.write("cannot add sub-directories of subdirectories - skipping: %s)\n" % sub_path)
                continue
            spec.exclude(sub_path)

    def _in_subtree(self, subtree, dir):
        if os.path.commonprefix([subtree, dir]) == subtree:
            return True
        else:
            return False

    def _print_files(self, root, files):
        for f in files:
            if self.file_type and not self.file_type.is_file_match(f):
                continue
            print os.path.join(root, f)

    def _filter_files(self, path_spec, files):
        """
        Call function with a lsit of files from the filesystem.  If
        there is an inclusion list, remove files that aren't in that
        list.  If there is an exclusion list, remove those from the
        list of files also.
        """
        if path_spec.file_inclusions:
            self._keep(entries=files, keepers=path_spec.file_inclusions)
        if path_spec.file_exclusions:
            self._lose(entries=files, losers=path_spec.file_exclusions)

    def _filter_dirs(self, path_spec, dirs):
        """
        Call function with full list of sub-directories from
        filesystem.  If there is an inclusion list, only keep the dirs
        that are in that list.  If there is an exlusion list, remove
        them from dirs also.
        """
        if path_spec.dir_inclusions:
            self._keep(entries=dirs, keepers=path_spec.dir_inclusions)
        if path_spec.dir_exclusions:
            self._lose(entries=dirs, losers=path_spec.dir_exclusions)

    def _get_path_spec(self, path_specs, path):
        for path_spec in path_specs:
            if path_spec.directory == path:
                return path_spec
        return None

    def _lose(self, entries, losers):
        orig_entries = entries[:]
        for e in orig_entries:
            if e in losers:
                entries.remove(e)

    def _keep(self, entries, keepers):
        orig_entries = entries[:]
        for e in orig_entries:
            if not e in keepers:
                entries.remove(e)



def load_config(finder, filename):
    """
    Load a config from filename or stdin
    """
    if filename == '-':
        config_file = sys.stdin;
    elif os.path.isfile(filename):
        config_file = open(filename)
    else:
        sys.stderr.write('Unable to find config file %s\n' % filename)
        return -1
    config = config_file.read()
    # Allow separation of commands by semi-colon
    config = re.sub(';', '\n', config)
    for line in config.splitlines():
        if re.match('^#', line) or len(line) < 1:
            continue
        finder.config(line)
    return 0



VERSION="1.0.0"
USAGE="""
efind, Copyright (C) 2018 Nathan Crapo
efind comes with ABSOLUTELY NO WARRANTY; for details
see GPLv2 header within.  This is free software, and you
are welcome to redistribute it under certain conditions;
see header for details.

Usage:
  efind [-t=TYPES] [-c=NAME] [-r PATH] [-s] [-a]
  efind config [-d] [-p PATH] <CONFIG>
  efind ls-configs [-p PATH]
  efind clone [-p PATH] <CONFIG>
  efind template [-p PATH] <CONFIG>
  efind cp [-p PATH] <CONFIG> <PATH>
  efind mv [-p PATH] <CONFIG> <PATH>
  efind rm [-p PATH] <CONFIG>
  efind include [-p PATH] <DIRS>
  efind exclude [-p PATH] <DIRS>
  efind enable [-p PATH] <CONFIG>
  efind disable [-p PATH] <CONFIG>
  efind (-v | --version)

Commands:
  config       Select a CONFIG or create a new one if it doesn't exist. Use
               'default' if no name given.
  ls-configs   List configs in current repo.
  clone        Pull template from home repo into current repo and activate
  template     Push CONFIG to home repo as template for future clone
  cp           Copy CONFIG to another repo in PATH
  mv           Move CONFIG to another repo in PATH
  rm           Delete CONFIG
  rotate       Move CONFIG to a new repo in PATH and translate internal
               paths to match
  include      Add directories to current CONFIG
  exlcude      Remove directories from current CONFIG
  enable       Include CONFIG in active config; effectively creating composite
  disable      Remove CONFIG from active config; reducing composite

Options:
  -c FILE, --config FILE      efind spec config file
  -d, --delete                delete specified config
  -t TYPE, --type TYPE        narrow to file type
  -r PATH, --repo PATH        path to efind repo
  -s, --subtree               only output files from cwd down
  -a, --absolute              use absolute paths
  -v, --version               print app version
"""
future_commands = """
  efind rotate
  efind hook add {complete|file|dir|each} <command>
  efind hook del {complete|file|dir|each}
"""

meta_structure = """
.efind/
    default   - default config
    templates - store configs as templates.  cannot be run from this dir.
"""

config_syntax = """
[at <dir>] include [dirs]
[at <dir>] exclude [dirs]
type <file-type>
layer <config>
hook {complete|file|dir|each} <command>
"""

def main():
    """

    """
    args = docopt(USAGE, version=VERSION)

    repo = Repo()
    repo.auto_locate(args['--repo'])
    start_dir = repo.get_root(args['--absolute'])
    subtree = None
    if args['--subtree']:
        subtree = os.getcwd()

    finder = Finder(start_dir)
    if args['--type']:
        try:
            finder.set_file_type(args['--type'])
        except ValueError as err:
            sys.stderr.write('%s\n' % err)
            return -1

    finder.config('exclude .efind')
    error = load_config(finder, repo.get_config_filename(args['--config']))
    if error:
        sys.exit(-1)

    finder.find(subtree)



if __name__ == "__main__":
    main()
